swap:
    mov     rax, QWORD PTR [rdi]        ; Загружаем значение из адреса rdi в rax
    mov     rdx, QWORD PTR [rsi]        ; Загружаем значение из адреса rsi в rdx
    mov     QWORD PTR [rdi], rdx        ; Перемещаем значение rdx в адрес rdi
    mov     QWORD PTR [rsi], rax        ; Перемещаем значение rax в адрес rsi
    ret                                 ; Возвращаемся
BubbleSort:
    cmp     rsi, 1                      ; Сравниваем размер массива (rsi) с 1
    je      .L2                         ; Если массив из одного элемента, переходим к завершению
    lea     r8, [rdi-8+rsi*8]           ; Вычисляем адрес последнего элемента массива
    jmp     .L4                         ; Переходим к началу внешнего цикла

.L9:
    mov     QWORD PTR [rax], rcx        ; Сохраняем меньшее значение по текущему адресу
    mov     QWORD PTR [rax+8], rdx      ; Сохраняем большее значение в следующий элемент
.L5:
    add     rax, 8                      ; Переходим к следующей паре элементов
    cmp     rax, r8                     ; Проверяем, достигли ли конца массива
    je      .L8                         ; Если да, завершаем внутренний цикл

.L6:
    mov     rdx, QWORD PTR [rax]        ; Загружаем текущее значение
    mov     rcx, QWORD PTR [rax+8]      ; Загружаем следующее значение
    cmp     rdx, rcx                    ; Сравниваем текущий и следующий элементы
    jle     .L5                         ; Если они в порядке, переходим к следующей паре
    jmp     .L9                         ; Если нет, выполняем перестановку

.L8:
    sub     rsi, 1                      ; Уменьшаем количество элементов для следующей итерации
    sub     r8, 8                       ; Смещаем конец массива на один элемент
    cmp     rsi, 1                      ; Проверяем, остались ли элементы для сортировки
    je      .L2                         ; Если массив отсортирован, завершаем

.L4:
    mov     rax, rdi                    ; Начинаем сортировку с начала массива
    jmp     .L6                         ; Переходим к внутреннему циклу

.L2:
    ret                                 ; Завершаем сортировку
main:
    push    r14                         ; Сохраняем регистры, используемые в функции
    push    r13
    push    r12
    push    rbp
    push    rbx
    sub     rsp, 16                     ; Выделяем место в стеке

    mov     rdx, QWORD PTR stdin[rip]   ; Загружаем указатель на стандартный ввод
    mov     esi, OFFSET FLAT:.LC0       ; Загружаем строку "r" для открытия файла
    mov     edi, OFFSET FLAT:.LC1       ; Загружаем имя файла "test.txt"
    call    freopen                     ; Перенаправляем стандартный ввод на файл

    mov     r13, rax                    ; Сохраняем указатель на файл
    lea     rdx, [rsp+8]                ; Указываем место для сохранения размера массива
    mov     esi, OFFSET FLAT:.LC2       ; Формат строки "%llu"
    mov     rdi, rax                    ; Указатель на файл
    mov     eax, 0                      ; Сбрасываем регистр для вызова функции
    call    __isoc99_fscanf             ; Читаем размер массива из файла

    mov     r12, QWORD PTR [rsp+8]      ; Сохраняем размер массива
    lea     rdi, [0+r12*8]              ; Вычисляем размер памяти для массива
    call    malloc                      ; Выделяем память под массив
    mov     r14, rax                    ; Сохраняем указатель на массив

    test    r12, r12                    ; Проверяем, что массив не пустой
    je      .L11                        ; Если пустой, пропускаем ввод значений

    mov     rbp, rax                    ; Устанавливаем указатель на текущий элемент массива
    mov     ebx, 0                      ; Сбрасываем счётчик элементов

.L12:
    mov     rdx, rbp                    ; Загружаем адрес текущего элемента
    mov     esi, OFFSET FLAT:.LC2       ; Формат строки "%llu"
    mov     rdi, r13                    ; Указатель на файл
    mov     eax, 0                      ; Сбрасываем регистр для вызова функции
    call    __isoc99_fscanf             ; Считываем элемент из файла

    add     rbx, 1                      ; Увеличиваем счётчик элементов
    mov     r12, QWORD PTR [rsp+8]      ; Загружаем размер массива
    add     rbp, 8                      ; Переходим к следующему элементу
    cmp     rbx, r12                    ; Проверяем, все ли элементы считаны
    jb      .L12                        ; Если нет, продолжаем ввод

.L11:
    mov     rsi, r12                    ; Передаём размер массива
    mov     rdi, r14                    ; Передаём указатель на массив
    call    BubbleSort                  ; Вызываем сортировку пузырьком

    mov     rdi, r14                    ; Передаём указатель на массив
    call    free                        ; Освобождаем память

    mov     eax, 0                      ; Завершаем программу
    add     rsp, 16                     ; Восстанавливаем стек
    pop     rbx                         ; Восстанавливаем регистры
    pop     rbp
    pop     r12
    pop     r13
    pop     r14
    ret                                 ; Возвращаем управление
